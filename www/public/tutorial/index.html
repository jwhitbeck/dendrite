<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.14" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title> Tutorial &middot; Dendrite </title>

  
  <link rel="stylesheet" href="http://dendrite.tech/css/poole.css">
  <link rel="stylesheet" href="http://dendrite.tech/css/syntax.css">
  <link rel="stylesheet" href="http://dendrite.tech/css/hyde.css">
  <link rel="stylesheet" href="http://dendrite.tech/css/custom.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

</head>

<body class="theme-base-0d">
  <div class="sidebar">
  <div class="container">
    <div class="sidebar-about">
      <a href="http://dendrite.tech/"><h1>Dendrite</h1></a>
      <p class="lead">
        A columnar storage format for Clojure
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="http://dendrite.tech/">Home</a> </li>
      
      <li><a href="https://github.com/jwhitbeck/dendrite"> Github project page </a></li>
      
      <li><a href="/tutorial/"> Tutorial </a></li>
      
      <li><a href="/api/"> API docs </a></li>
      
      <li><a href="/benchmarks/"> Benchmarks </a></li>
      
      <li><a href="/format/"> File format </a></li>
      
      <li><a href="/shredding/"> Record shredding </a></li>
      
      <li><a href="/implementation/"> Implementation notes </a></li>
      
    </ul>

    <span class="copyright sidebar-sticky">&copy; John Whitbeck 2015. All rights reserved.</span>
  </div>
</div>

  <div id="menu">
  <a href="#"></a>
</div>


  <div class="content container">
    <div class="post">
      

<h1 id="tutorial:94d9a081cd1256334373c8ca6fb6276c">Tutorial</h1>

<p>Let&rsquo;s get started with dendrite. This tutorial will take you through the basics of file I/O, show you how take
advantage of the columnar format for your queries, and how to efficiently apply transformations on reads.</p>

<p>The examples below assume that you have required the <code>dendrite.core</code> namespace as follows:</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">dendrite.core</span> <span class="ss">:as</span> <span class="nv">d</span><span class="p">])</span>
</pre></div>
</p>

<h2 id="read-and-write-files:94d9a081cd1256334373c8ca6fb6276c">Read and write files</h2>

<p>Writing to dendrite files should feel very similar to writing other types of files in clojure.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">filename</span> <span class="s">&quot;contacts.den&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="k">def </span><span class="nv">schema</span> <span class="p">{</span><span class="ss">:name</span> <span class="p">{</span><span class="ss">:first</span> <span class="ss">&#39;string</span>
                    <span class="ss">:last</span> <span class="ss">&#39;string</span><span class="p">}</span>
             <span class="ss">:emails</span> <span class="p">[</span><span class="ss">&#39;string</span><span class="p">]})</span>

<span class="p">(</span><span class="k">def </span><span class="nv">contacts</span>
  <span class="p">[{</span><span class="ss">:name</span> <span class="p">{</span><span class="ss">:first</span> <span class="s">&quot;Alice&quot;</span>
           <span class="ss">:last</span> <span class="s">&quot;Jones&quot;</span><span class="p">}</span>
    <span class="ss">:emails</span> <span class="p">[</span><span class="s">&quot;alice@jones.com&quot;</span> <span class="s">&quot;alice@acme.org&quot;</span><span class="p">]}</span>

   <span class="p">{</span><span class="ss">:name</span> <span class="p">{</span><span class="ss">:first</span> <span class="s">&quot;Bob&quot;</span>
           <span class="ss">:last</span> <span class="s">&quot;Smith&quot;</span><span class="p">}</span>
    <span class="ss">:emails</span> <span class="p">[</span><span class="s">&quot;bob@smith.com&quot;</span><span class="p">]}])</span>

<span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">w</span> <span class="p">(</span><span class="nf">d/file-writer</span> <span class="nv">schema</span> <span class="nv">filename</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">c</span> <span class="nv">contacts</span><span class="p">]</span>
    <span class="p">(</span><span class="nf">.write</span> <span class="nv">w</span> <span class="nv">c</span><span class="p">)))</span>
</pre></div>
</p>

<p>A few things to note:</p>

<ul>
<li>The writer needs to be aware of the <em>schema</em> describing the structure and the types of the records to be
serialized. We&rsquo;ll see more advanced schemas later on, but you can think of them as basically just the same
clojure object with type symbols instead of leaf values.</li>
<li>The records are passed <em>as-is</em> to the writer. No extra serialization step is needed.</li>
</ul>

<p>In this example, the schema has three <em>columns</em>. The nested structure of the objects is encoded in the schema,
but the leaf values (e.g., &ldquo;Alice&rdquo;, &ldquo;bob@smith.com&rdquo;) are written out to three separate columns. For a good
primer on how this is done in practice, check out this
<a href="https://blog.twitter.com/2013/dremel-made-simple-with-parquet">blog post</a> from the
<a href="https://parquet.apache.org/">Parquet</a> project.</p>

<p>Reading is even simpler. Since the schema is stored within the file, it is not required for reading.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">filename</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">doall </span><span class="p">(</span><span class="nf">d/read</span> <span class="nv">r</span><span class="p">)))</span>
<span class="c1">;= ({:name {:first &quot;Alice&quot; :last &quot;Jones&quot;}</span>
<span class="c1">;    :emails [&quot;alice@jones.com&quot; &quot;alice@acme.org&quot;]}</span>
<span class="c1">;   {:name {:first &quot;Bob&quot; :last &quot;Smith&quot;}</span>
<span class="c1">;    :emails [&quot;bob@smith.com&quot;]})</span>
</pre></div>
</p>

<h2 id="supported-types:94d9a081cd1256334373c8ca6fb6276c">Supported types</h2>

<p>Dendrite&rsquo;s built-in types are a superset of those of <a href="https://github.com/edn-format/edn
">EDN</a>. In dendrite schemas, types are
denoted using clojure symbols.</p>

<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>boolean</code></td>
<td>true or false</td>
</tr>

<tr>
<td><code>int</code></td>
<td>a 32-bit integer</td>
</tr>

<tr>
<td><code>long</code></td>
<td>a 64-bit integer</td>
</tr>

<tr>
<td><code>float</code></td>
<td>an IEEE 32-bit floating point value</td>
</tr>

<tr>
<td><code>double</code></td>
<td>an IEEE 64-bit floating point value</td>
</tr>

<tr>
<td><code>byte-array</code></td>
<td>an arbitrary byte-array</td>
</tr>

<tr>
<td><code>fixed-length-byte-array</code></td>
<td>a byte array with a set size</td>
</tr>

<tr>
<td><code>string</code></td>
<td>a string</td>
</tr>

<tr>
<td><code>inst</code></td>
<td>a date</td>
</tr>

<tr>
<td><code>uuid</code></td>
<td>a Universally Unique identifier</td>
</tr>

<tr>
<td><code>char</code></td>
<td>a character or 16-bit integer</td>
</tr>

<tr>
<td><code>bigint</code></td>
<td>an arbitrary-size integer</td>
</tr>

<tr>
<td><code>bigdec</code></td>
<td>an arbitrary-precision decimal number</td>
</tr>

<tr>
<td><code>ratio</code></td>
<td>a ratio of two arbitrary-precision numbers</td>
</tr>

<tr>
<td><code>keyword</code></td>
<td>an EDN keyword</td>
</tr>

<tr>
<td><code>symbol</code></td>
<td>an EDN symbol</td>
</tr>

<tr>
<td><code>byte-buffer</code></td>
<td>a java.nio.ByteBuffer</td>
</tr>
</tbody>
</table>

<p>The <code>boolean</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>byte-array</code>, and <code>fixed-length-byte-array</code> types are
dendrite&rsquo;s <em>primitive types</em>. All the others are <em>logical types</em> that converted to and form a <em>primitive type</em>
during serialization and deserialization. This list of types can be easily extended to suit your needs by
defining <a href="#custom-types:94d9a081cd1256334373c8ca6fb6276c">custom logical types</a>.</p>

<p>In the spirit of &ldquo;generous on input, strict on output&rdquo;, each type is associated with a <em>coercion function</em>
that does its best to convert the input data into the desired type.</p>

<p>For example, let&rsquo;s write to a simple file containing where records are just simple strings.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">w</span> <span class="p">(</span><span class="nf">d/file-writer</span> <span class="ss">&#39;string</span> <span class="s">&quot;tmp.den&quot;</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">v</span> <span class="p">[</span><span class="mf">0.1</span>   <span class="c1">; double</span>
             <span class="mi">100</span>   <span class="c1">; long</span>
             <span class="s">&quot;foo&quot;</span> <span class="c1">; string</span>
             <span class="ss">:bar</span>  <span class="c1">; keyword</span>
             <span class="ss">&#39;baz</span>  <span class="c1">; symbol</span>
            <span class="p">]]</span>
    <span class="p">(</span><span class="nf">.write</span> <span class="nv">w</span> <span class="nv">v</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="s">&quot;tmp.den&quot;</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">doall </span><span class="p">(</span><span class="nf">d/read</span> <span class="nv">r</span><span class="p">)))</span>
<span class="c1">;= (&quot;0.1&quot; &quot;100&quot; &quot;foo&quot; &quot;:bar&quot; &quot;baz&quot;)</span>
</pre></div>
</p>

<p>Note that all the values were converted to strings before being written. Obviously, it isn&rsquo;t always possible
to convert input values to the desired type.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">w</span> <span class="p">(</span><span class="nf">d/file-writer</span> <span class="ss">&#39;int</span> <span class="s">&quot;tmp.den&quot;</span><span class="p">)]</span>
   <span class="p">(</span><span class="nf">.write</span> <span class="nv">w</span> <span class="s">&quot;foo&quot;</span><span class="p">))</span>
<span class="c1">; IllegalArgumentException Could not coerce &#39;foo&#39; into a int.</span>
</pre></div>
</p>

<h2 id="read-subsets-of-the-data:94d9a081cd1256334373c8ca6fb6276c">Read subsets of the data</h2>

<p>Columnar storage formats shine when only reading subsets of the data. Indeed, the on-disk bytes for unselected
columns can be skipped entirely. Dendrite has two mechanisms for restricting the amount of data that needs to
be deserialized: sub-schemas and queries. As we will see, they can be used separately or together.</p>

<h3 id="sub-schemas:94d9a081cd1256334373c8ca6fb6276c">Sub-schemas</h3>

<p>Sub-schemas are the simplest way of drilling down into the records contained in a dendrite file. They are the
equivalent of calling <code>get-in</code> on each record. The following examples use the second arity of
<code>dendrite.core/read</code> that expects an options map as its first arg.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">filename</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">doall </span><span class="p">(</span><span class="nf">d/read</span> <span class="p">{</span><span class="ss">:sub-schema-in</span> <span class="p">[</span><span class="ss">:name</span><span class="p">]}</span> <span class="nv">r</span><span class="p">)))</span>
<span class="c1">;= ({:first &quot;Alice&quot; :last &quot;Jones&quot;}</span>
<span class="c1">;   {:first &quot;Bob&quot; :last &quot;Smith&quot;})</span>

<span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">filename</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">doall </span><span class="p">(</span><span class="nf">d/read</span> <span class="p">{</span><span class="ss">:sub-schema-in</span> <span class="p">[</span><span class="ss">:name</span> <span class="ss">:first</span><span class="p">]}</span> <span class="nv">r</span><span class="p">)))</span>
<span class="c1">;= (&quot;Alice&quot; &quot;Bob&quot;)</span>

<span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">filename</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">doall </span><span class="p">(</span><span class="nf">d/read</span> <span class="p">{</span><span class="ss">:sub-schema-in</span> <span class="p">[</span><span class="ss">:emails</span><span class="p">]}</span> <span class="nv">r</span><span class="p">)))</span>
<span class="c1">;= ([&quot;alice@jones.com&quot; &quot;alice@acme.org&quot;]</span>
<span class="c1">;   [&quot;bob@smith.com&quot;])</span>
</pre></div>
</p>

<p>Attempting to use the <code>:sub-schema-in</code> option to cross into a repeated field will throw an exception.</p>

<h3 id="queries:94d9a081cd1256334373c8ca6fb6276c">Queries</h3>

<p>Queries specify a &lsquo;skeleton&rsquo; structure of the records that should be read from the file.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">filename</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">doall </span><span class="p">(</span><span class="nf">d/read</span> <span class="p">{</span><span class="ss">:query</span> <span class="p">{</span><span class="ss">:name</span> <span class="p">{</span><span class="ss">:last</span> <span class="ss">&#39;string</span><span class="p">}}}</span> <span class="nv">r</span><span class="p">)))</span>
<span class="c1">;= ({:name {:last &quot;Jones&quot;}}</span>
<span class="c1">;   {:name {:last &quot;Smith&quot;}})</span>
</pre></div>
</p>

<p>For ease of use, underscore symbols in queries are a shorthand for <em>everything in the schema under this
point</em>. For example, the following code snippet defines the same query as above.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">filename</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">doall </span><span class="p">(</span><span class="nf">d/read</span> <span class="p">{</span><span class="ss">:query</span> <span class="p">{</span><span class="ss">:name</span> <span class="p">{</span><span class="ss">:last</span> <span class="ss">&#39;_</span><span class="p">}}}</span> <span class="nv">r</span><span class="p">)))</span>
<span class="c1">;= ({:name {:last &quot;Jones&quot;}}</span>
<span class="c1">;   {:name {:last &quot;Smith&quot;}})</span>
</pre></div>
</p>

<p>Underscore symbols can stand in for entire sub-schemas.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">filename</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">doall </span><span class="p">(</span><span class="nf">d/read</span> <span class="p">{</span><span class="ss">:query</span> <span class="p">{</span><span class="ss">:name</span> <span class="ss">&#39;_</span><span class="p">}}</span> <span class="nv">r</span><span class="p">)))</span>
<span class="c1">;= ({:name {:first &quot;Alice&quot; :last &quot;Jones&quot;}}</span>
<span class="c1">;   {:name {:first &quot;Bob&quot; :last &quot;Smith&quot;}})</span>
</pre></div>
</p>

<h3 id="sub-schema-queries:94d9a081cd1256334373c8ca6fb6276c">Sub-schema queries</h3>

<p>It is of course possible to combine sub-schemas and queries. If both the <code>:sub-schema-in</code> and <code>:query</code> options
are provided, the query is applied to the sub-schema.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">filename</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">doall </span><span class="p">(</span><span class="nf">d/read</span> <span class="p">{</span><span class="ss">:sub-schema-in</span> <span class="p">[</span><span class="ss">:name</span><span class="p">]</span> <span class="ss">:query</span> <span class="p">{</span><span class="ss">:first</span> <span class="ss">&#39;_</span><span class="p">}}</span> <span class="nv">r</span><span class="p">)))</span>
<span class="c1">;= ({:first &quot;Alice&quot;} {:first &quot;Bob&quot;})</span>
</pre></div>
</p>

<h2 id="metadata:94d9a081cd1256334373c8ca6fb6276c">Metadata</h2>

<p>Dendrite files may contain arbitrary file-level metadata. This is useful in many contexts, whether you want to
keep track of the commit sha1 of the code that created the file or just add a description.</p>

<p>Set the metadata with <code>set-metadata!</code>.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">w</span> <span class="p">(</span><span class="nf">d/file-writer</span> <span class="nv">schema</span> <span class="nv">filename</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">c</span> <span class="nv">contacts</span><span class="p">]</span>
    <span class="p">(</span><span class="nf">.write</span> <span class="nv">w</span> <span class="nv">c</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">d/set-metadata!</span> <span class="nv">w</span> <span class="p">{</span><span class="ss">:description</span> <span class="s">&quot;Contacts&quot;</span> <span class="ss">:owner</span> <span class="s">&quot;carl&quot;</span><span class="p">})</span>
</pre></div>
</p>

<p>Read the metadata with <code>metadata</code>.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">filename</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">d/metadata</span> <span class="nv">r</span><span class="p">))</span>
<span class="c1">;= {:description &quot;Contacts&quot; :owner &quot;carl&quot;}</span>
</pre></div>
</p>

<h2 id="opt-into-strictness:94d9a081cd1256334373c8ca6fb6276c">Opt into strictness</h2>

<h3 id="tolerant-writes-by-default:94d9a081cd1256334373c8ca6fb6276c">Tolerant writes by default</h3>

<p>By default, dendrite is quite tolerant about writing objects that don&rsquo;t strictly adhere to the write
schema. Specifically, it considers that all fields are optional and silently drops fields that are not in the
schema.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">contact-with-no-name</span>
  <span class="p">{</span><span class="ss">:emails</span> <span class="p">[</span><span class="s">&quot;noname@none.com&quot;</span><span class="p">]})</span>

<span class="p">(</span><span class="k">def </span><span class="nv">contact-with-extra-fields</span>
  <span class="p">{</span><span class="ss">:name</span> <span class="p">{</span><span class="ss">:first</span> <span class="s">&quot;Alice&quot;</span> <span class="ss">:last</span> <span class="s">&quot;Jones&quot;</span><span class="p">}</span>
   <span class="ss">:emails</span> <span class="p">[</span><span class="nv">nil</span><span class="p">]</span>
   <span class="ss">:age</span> <span class="mi">24</span><span class="p">})</span>

<span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">w</span> <span class="p">(</span><span class="nf">d/file-writer</span> <span class="nv">schema</span> <span class="nv">filename</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">.write</span> <span class="nv">w</span> <span class="nv">contact-with-no-name</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">.write</span> <span class="nv">w</span> <span class="nv">nil</span><span class="p">)</span> <span class="c1">; Completely empty record</span>
  <span class="p">(</span><span class="nf">.write</span> <span class="nv">w</span> <span class="nv">contact-with-extra-fields</span><span class="p">))</span>

<span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">filename</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">doall </span><span class="p">(</span><span class="nf">d/read</span> <span class="nv">r</span><span class="p">)))</span>
<span class="c1">;= ({:emails [&quot;noname@none.com&quot;]}</span>
<span class="c1">;   nil</span>
<span class="c1">;   {:name {:first &quot;Alice&quot; :last &quot;Jones&quot;}</span>
<span class="c1">;   :emails [nil]})</span>
</pre></div>
</p>

<p>Notice how Alice&rsquo;s age was not written to the file.</p>

<h3 id="required-fields:94d9a081cd1256334373c8ca6fb6276c">Required fields</h3>

<p>In many cases, it is useful to enforce the presence of certain record elements and throw an exception if any
are missing. Dendrite schemas can be annotated to mark certain elements as required (i.e., cannot be nil)
using the &rsquo;d/req` function.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">strict-schema</span>
  <span class="p">(</span><span class="nf">d/req</span> <span class="c1">; nil records not allowed</span>
    <span class="c1">; :name must be present but :first and :last are still optional</span>
    <span class="p">{</span><span class="ss">:name</span> <span class="p">(</span><span class="nf">d/req</span> <span class="p">{</span><span class="ss">:first</span> <span class="ss">&#39;string</span>
                   <span class="ss">:last</span> <span class="ss">&#39;string</span><span class="p">})</span>
     <span class="c1">; :emails is optional but, if defined, the</span>
     <span class="c1">;  email strings cannot be nil</span>
     <span class="ss">:emails</span> <span class="p">[(</span><span class="nf">d/req</span> <span class="ss">&#39;string</span><span class="p">)]}))</span>
</pre></div>
</p>

<p>Let&rsquo;s try writing the same records as in the previous example using this stricter schema.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">w</span> <span class="p">(</span><span class="nf">d/file-writer</span> <span class="nv">strict-schema</span> <span class="nv">filename</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">.write</span> <span class="nv">w</span> <span class="nv">contact-with-no-name</span><span class="p">))</span>
<span class="c1">; Throws exception. Required field :name is missing</span>

<span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">w</span> <span class="p">(</span><span class="nf">d/file-writer</span> <span class="nv">strict-schema</span> <span class="nv">filename</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">.write</span> <span class="nv">w</span> <span class="nv">nil</span><span class="p">))</span>
<span class="c1">; Throws exception. Required record is missing</span>

<span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">w</span> <span class="p">(</span><span class="nf">d/file-writer</span> <span class="nv">strict-schema</span> <span class="nv">filename</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">.write</span> <span class="nv">w</span> <span class="nv">contact-with-extra-fields</span><span class="p">))</span>
<span class="c1">; Throws exception. Required email is nil.</span>
</pre></div>
</p>

<h3 id="alert-on-extra-fields:94d9a081cd1256334373c8ca6fb6276c">Alert on extra fields</h3>

<p>Keeping schemas in sync with application code can be tricky. In particular, you may want to throw an error if
the record to write contains fields that are not present in the schema. The <code>d/file-writer</code> function has a
second arity that accepts an options map to customize the writer&rsquo;s behavior. In this case, we want to set
<code>:ignore-extra-fields?</code> to <code>false</code>.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">w</span> <span class="p">(</span><span class="nf">d/file-writer</span> <span class="p">{</span><span class="ss">:ignore-extra-fields?</span> <span class="nv">false</span><span class="p">}</span>
                              <span class="nv">schema</span> <span class="nv">filename</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">.write</span> <span class="nv">w</span> <span class="nv">contact-with-extra-fields</span><span class="p">))</span>
<span class="c1">; Throws exception. :age is not is schema.</span>
</pre></div>
</p>

<h3 id="handle-invalid-records:94d9a081cd1256334373c8ca6fb6276c">Handle invalid records</h3>

<p>In some contexts, it may be preferable to handle the occasional invalid record rather than crashing the
writing process. Dendrite supports that use case through the <code>:invalid-input-handler</code> option. This is a
function of two arguments: the record and the exception. Let&rsquo;s use this to populate an atom of invalid
records.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">invalid-records</span> <span class="p">(</span><span class="nf">atom</span> <span class="p">[]))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">handler</span> <span class="p">[</span><span class="nv">rec</span> <span class="nv">e</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">swap!</span> <span class="nv">invalid-records</span> <span class="nb">conj </span><span class="nv">rec</span><span class="p">))</span>

<span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">w</span> <span class="p">(</span><span class="nf">d/file-writer</span> <span class="p">{</span><span class="ss">:invalid-input-handler</span> <span class="nv">handler</span><span class="p">}</span>
                             <span class="nv">strict-schema</span> <span class="nv">filename</span><span class="p">)]</span>
  <span class="c1">; Write some valid contacts</span>
  <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">c</span> <span class="nv">contacts</span><span class="p">]</span>
    <span class="p">(</span><span class="nf">.write</span> <span class="nv">w</span> <span class="nv">c</span><span class="p">))</span>
  <span class="c1">; Write an invalid contact</span>
  <span class="p">(</span><span class="nf">.write</span> <span class="nv">w</span> <span class="nv">contact-with-no-name</span><span class="p">))</span>
<span class="c1">;= nil</span>

<span class="o">@</span><span class="nv">invalid-records</span>
<span class="c1">;= [{:emails [&quot;noname@none.com&quot;]}]</span>

<span class="c1">; Verify that the valid records were successfully written</span>
<span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">filename</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">count </span><span class="p">(</span><span class="nf">d/read</span> <span class="nv">r</span><span class="p">)))</span>
<span class="c1">;= 2</span>
</pre></div>
</p>

<h3 id="read-missing-columns:94d9a081cd1256334373c8ca6fb6276c">Read missing columns</h3>

<p>The previous sections covered enforcing various write-time checks. By default, dendrite is also quite tolerant
on reads. In particular, if a query requests fields that are not present in the file&rsquo;s schema, those fields
will simply be ignored.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">filename</span><span class="p">)]</span>
  <span class="c1">; The :age field does not exist in the schema</span>
  <span class="p">(</span><span class="nb">doall </span><span class="p">(</span><span class="nf">d/read</span> <span class="p">{</span><span class="ss">:query</span> <span class="p">{</span><span class="ss">:name</span> <span class="p">{</span><span class="ss">:first</span> <span class="ss">&#39;_</span><span class="p">}</span> <span class="ss">:age</span> <span class="ss">&#39;_</span><span class="p">}}</span> <span class="nv">r</span><span class="p">)))</span>
<span class="c1">;= ({:name {:first &quot;Alice&quot;}}</span>
<span class="c1">;   {:name {:first &quot;Bob&quot;}})</span>
</pre></div>
</p>

<p>This makes it very easy to apply the same query to many files, of which some may not have the requested
field. However, this tolerant behavior may not always be desirable and can be disabled by setting the
<code>:missing-fields-as-nil?</code> read option to <code>false</code>.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">filename</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">doall </span><span class="p">(</span><span class="nf">d/read</span> <span class="p">{</span><span class="ss">:query</span> <span class="p">{</span><span class="ss">:name</span> <span class="p">{</span><span class="ss">:first</span> <span class="ss">&#39;_</span><span class="p">}</span> <span class="ss">:age</span> <span class="ss">&#39;_</span><span class="p">}</span>
                  <span class="ss">:missing-fields-as-nil?</span> <span class="nv">false</span><span class="p">}</span>
                  <span class="nv">r</span><span class="p">)))</span>
<span class="c1">;= Throws exception. :age field does not exist.</span>
</pre></div>
</p>

<h2 id="schema-manipulation:94d9a081cd1256334373c8ca6fb6276c">Schema manipulation</h2>

<p>Dendrite schemas are regular immutable clojure objects and not a separate DSL. This may seem like a detail but
it makes them very easy to build and modify programatically. All the usual clojure data manipulation functions
such as <code>assoc</code>, <code>dissoc</code>, or <code>merge</code> will work as expected on schemas. Furthermore, they can be serialized to
<a href="https://github.com/edn-format/edn">EDN</a> using the usual <code>pr-*</code> functions.</p>

<h3 id="modify-an-existing-schema:94d9a081cd1256334373c8ca6fb6276c">Modify an existing schema</h3>

<p>Let&rsquo;s say we want to add an id to all our contacts. We could read-in all the existing contacts and use <code>range</code>
to add a simple incrementing id to the existing contacts.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">filename</span><span class="p">)]</span>
  <span class="c1">;; Add the :id field with type long to the schema.</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">schema-with-id</span> <span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">d/schema</span> <span class="nv">r</span><span class="p">)</span> <span class="p">(</span><span class="nb">assoc </span><span class="ss">:id</span> <span class="ss">&#39;long</span><span class="p">))]</span>
    <span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">w</span> <span class="p">(</span><span class="nf">d/file-writer</span> <span class="nv">schema-with-id</span> <span class="s">&quot;contacts2.den&quot;</span><span class="p">)]</span>
      <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">c</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">assoc </span><span class="nv">%1</span> <span class="ss">:id</span> <span class="nv">%2</span><span class="p">)</span> <span class="p">(</span><span class="nf">d/read</span> <span class="nv">r</span><span class="p">)</span> <span class="p">(</span><span class="nf">range</span><span class="p">))]</span>
        <span class="p">(</span><span class="nf">.write</span> <span class="nv">w</span> <span class="nv">c</span><span class="p">)))))</span>
</pre></div>
</p>

<p>Let&rsquo;s see if that worked.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="s">&quot;contacts2.den&quot;</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">doall </span><span class="p">(</span><span class="nf">d/read</span> <span class="nv">r</span><span class="p">)))</span>
<span class="c1">;= ({:id 0</span>
<span class="c1">;    :name {:first &quot;Alice&quot;, :last &quot;Jones&quot;}</span>
<span class="c1">;    :emails [&quot;alice@jones.com&quot; &quot;alice@acme.org&quot;]}</span>
<span class="c1">;   {:id 1</span>
<span class="c1">;    :name {:first &quot;Bob&quot;, :last &quot;Smith&quot;}</span>
<span class="c1">;    :emails [&quot;bob@smith.com&quot;]})</span>
</pre></div>
</p>

<h3 id="schema-serialization:94d9a081cd1256334373c8ca6fb6276c">Serialization</h3>

<p>So far in this tutorial, schemas have been defined directly in the clojure code. However it is often
convenient to store them in separate files.</p>

<p><div class="highlight"><pre><span class="c1">; The simple schema from the beginning of the tutorial</span>
<span class="p">(</span><span class="nf">spit</span> <span class="s">&quot;schema.edn&quot;</span> <span class="p">(</span><span class="nb">pr-str </span><span class="nv">schema</span><span class="p">))</span>
<span class="c1">; The somewhat stricter schema from the &quot;Opting into strictness&quot;</span>
<span class="c1">; section</span>
<span class="p">(</span><span class="nf">spit</span> <span class="s">&quot;strict-schema.edn&quot;</span> <span class="p">(</span><span class="nb">pr-str </span><span class="nv">strict-schema</span><span class="p">))</span>
</pre></div>
</p>

<p>Let&rsquo;s see what those files look like.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">slurp </span><span class="s">&quot;schema.edn&quot;</span><span class="p">)</span>
<span class="c1">;= &quot;{:name {:first string, :last string}, :emails [string]}&quot;</span>
<span class="p">(</span><span class="nb">slurp </span><span class="s">&quot;strict-schema.edn&quot;</span><span class="p">)</span>
<span class="c1">;= &quot;#req {:name #req {:first string, :last string}, :emails [#req string]}&quot;</span>
</pre></div>
</p>

<p>Note how the required parts of the schema are tagged with <code>#req</code> in the EDN string. Pretty-printing also works
as expected and makes large schemas easier to inspect.</p>

<p>To read a schema, use the <code>d/read-schema-string</code> function. This is basically the same as
<code>clojure.edn/read-string</code> with special reader functions for the <code>#req</code> and <code>#col</code> schema annotations (see the
<a href="#manual-column-settings:94d9a081cd1256334373c8ca6fb6276c">manual column settings</a> section below for a description of <code>#col</code>).</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">-&gt; </span><span class="s">&quot;schema.edn&quot;</span> <span class="nb">slurp </span><span class="nv">d/read-schema-string</span><span class="p">))</span>
<span class="c1">;= {:name {:first &#39;string :last &#39;string}</span>
<span class="c1">;          :emails [&#39;string]}</span>
</pre></div>
</p>

<h2 id="file-introspection:94d9a081cd1256334373c8ca6fb6276c">File introspection</h2>

<p>The following sections benefit from a good understanding of dendrite&rsquo;s <a href="/shredding/">variation</a> on the <a href="http://research.google.com/pubs/pub36632.html
">Dremel</a> record shredding algorithm, its <a href="/format/">file format</a>, and its multi-threaded <a href="/implementation/">implementation</a>.</p>

<p>Furthermore, this section and all the following drop the toy <em>contacts</em> schema used up until now and instead
rely on a test dataset consisting of 100,000 records from the <a href="/benchmarks/#media-content:e40908f34f34adb446212d2eca21c8dd">media-content benchmark</a>.</p>

<p>Download the <a href="https://s3.amazonaws.com/files.dendrite.tech/tutorial.den
">tutorial file</a> (6MB) and reference it from your REPL.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">file</span> <span class="s">&quot;/path/to/tutorial.den&quot;</span><span class="p">)</span>
</pre></div>
</p>

<p>As a columnar format, the file layout is very structured and must store data about its own organization. The
<code>d/stats</code> function retrieves low-level statistics from this internal file metadata.  These stats are useful
for debugging performance (e.g. what column takes up the most bytes?). The <code>d/stats</code> function returns an
object with three keys <code>:global</code>, <code>:columns</code>, and <code>:record-groups</code>.</p>

<h3 id="global-stats:94d9a081cd1256334373c8ca6fb6276c">Global stats</h3>

<p>Let&rsquo;s look at the global stats for the tutorial file.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">file</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">r</span> <span class="nv">d/stats</span> <span class="ss">:global</span><span class="p">))</span>

<span class="c1">;= {:num-records 100000</span>
<span class="c1">;   :num-record-groups 1</span>
<span class="c1">;   :num-columns 17</span>
<span class="c1">;   :length 6421801</span>
<span class="c1">;   :definition-levels-length 156</span>
<span class="c1">;   :repetition-levels-length 212898</span>
<span class="c1">;   :data-header-length 429</span>
<span class="c1">;   :data-length 5941004</span>
<span class="c1">;   :dictionary-header-length 57</span>
<span class="c1">;   :dictionary-length 266664</span>
<span class="c1">;   :metadata-length 422}</span>
</pre></div>
</p>

<p>All the <code>-length</code> values are in bytes. In the global stats, these values are aggregated across all
record-groups and column chunks in the file.</p>

<h3 id="column-stats:94d9a081cd1256334373c8ca6fb6276c">Column stats</h3>

<p>The object returned by <code>d/stats</code> has a <code>:columns</code> key that points to column stats aggregated across
record-groups.</p>

<p>Let&rsquo;s look a the stats for the first column.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">file</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">r</span> <span class="nv">d/stats</span> <span class="ss">:columns</span> <span class="nv">first</span><span class="p">))</span>

<span class="c1">;= {:path [:id]</span>
<span class="c1">;   :type int</span>
<span class="c1">;   :encoding delta</span>
<span class="c1">;   :compression deflate</span>
<span class="c1">;   :max-definition-level 0</span>
<span class="c1">;   :max-repetition-level 0</span>
<span class="c1">;   :length 2137</span>
<span class="c1">;   :definition-levels-length 0</span>
<span class="c1">;   :repetition-levels-length 0</span>
<span class="c1">;   :data-header-length 9</span>
<span class="c1">;   :data-length 2128</span>
<span class="c1">;   :dictionary-header-length 0</span>
<span class="c1">;   :dictionary-length 0</span>
<span class="c1">;   :num-values 100000</span>
<span class="c1">;   :num-dictionary-values 0</span>
<span class="c1">;   :num-non-nil-values 100000</span>
<span class="c1">;   :num-column-chunks 1</span>
<span class="c1">;   :num-pages 1}</span>
</pre></div>
</p>

<p>Here we can see this is the column for the top-level <code>:id</code> field in the <a href="/benchmarks/#media-content-record:e40908f34f34adb446212d2eca21c8dd">media-content record</a>. It consists of 32 bit integers encoded using the
<a href="/format/#int-delta:d3946b20e9d5883ac2fef36d3bd47169">delta encoding</a> and compressed with <a href="/format/#deflate:d3946b20e9d5883ac2fef36d3bd47169">deflate</a>. Since its <em>max-definition-level</em> and <em>max-repetition-level</em> are both zero, this
column is required (i.e., cannot be nil) and non-repeated. Since the <code>:id</code> values are ordered, delta encoding
is very efficient and packs all 100,000 values into a single 2KB page (approx 0.02 bytes/values).</p>

<p>Now let&rsquo;s identify the largest columns in the file.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.pprint</span> <span class="ss">:as</span> <span class="nv">pp</span><span class="p">])</span>

<span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">file</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">d/stats</span> <span class="nv">r</span><span class="p">)</span>
       <span class="ss">:columns</span>
       <span class="p">(</span><span class="nb">sort-by </span><span class="ss">:length</span><span class="p">)</span>
       <span class="nv">reverse</span>
       <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">select-keys </span><span class="nv">%</span> <span class="p">[</span><span class="ss">:path</span> <span class="ss">:type</span> <span class="ss">:length</span><span class="p">]))</span>
       <span class="p">(</span><span class="nb">take </span><span class="mi">10</span><span class="p">)</span>
       <span class="nv">pp/print-table</span><span class="p">))</span>

<span class="c1">;  |                 :path |  :type | :length |</span>
<span class="c1">;  |-----------------------+--------+---------|</span>
<span class="c1">;  |    [:images nil :uri] | string | 3064652 |</span>
<span class="c1">;  |         [:media :uri] | string | 1009330 |</span>
<span class="c1">;  | [:media :persons nil] | string |  753994 |</span>
<span class="c1">;  |  [:images nil :title] | string |  344648 |</span>
<span class="c1">;  |        [:media :size] |    int |  212518 |</span>
<span class="c1">;  |    [:media :duration] |    int |  209329 |</span>
<span class="c1">;  | [:images nil :height] |    int |  187988 |</span>
<span class="c1">;  |  [:images nil :width] |    int |  187987 |</span>
<span class="c1">;  |   [:media :copyright] | string |  116722 |</span>
<span class="c1">;  |       [:media :title] | string |  106425 |</span>
</pre></div>
</p>

<p>Notice how some paths contain a <code>nil</code>. This just indicates that the path is traversing a repeated element in
that position.</p>

<h2 id="read-transformations:94d9a081cd1256334373c8ca6fb6276c">Read transformations</h2>

<h3 id="reducers:94d9a081cd1256334373c8ca6fb6276c">Reducers</h3>

<p>The object returned by <code>d/read</code> is not only seqable but also reducible and foldable in the
<a href="http://clojure.org/reducers
">core.reducers</a> sense.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.core.reducers</span> <span class="ss">:as</span> <span class="nv">r</span><span class="p">])</span>

<span class="c1">; Compute the sum of all durations in the datasets that are greater than 1000</span>
<span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">file</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">d/read</span> <span class="p">{</span><span class="ss">:sub-schema-in</span> <span class="p">[</span><span class="ss">:media</span> <span class="ss">:duration</span><span class="p">]}</span> <span class="nv">r</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">r/filter</span> <span class="o">#</span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">%</span> <span class="mi">1000</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">r/reduce</span> <span class="nv">+</span><span class="p">)))</span>
<span class="c1">;= 165920499</span>
</pre></div>
</p>

<p>Following the <a href="http://clojure.org/reducers
">core.reducers</a> contract, the code above doesn&rsquo;t build up any
intermediate lazy sequence. However, the real gains come from folding.</p>

<p><div class="highlight"><pre><span class="c1">; Same as above but faster</span>
<span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">file</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">d/read</span> <span class="p">{</span><span class="ss">:sub-schema-in</span> <span class="p">[</span><span class="ss">:media</span> <span class="ss">:duration</span><span class="p">]}</span> <span class="nv">r</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">r/filter</span> <span class="o">#</span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">%</span> <span class="mi">1000</span><span class="p">))</span>
       <span class="p">(</span><span class="nf">r/fold</span> <span class="nv">+</span><span class="p">)))</span>
<span class="c1">;= 165920499</span>
</pre></div>
</p>

<p>In the example above, <code>r/fold</code> will apply the filter and compute a partial sum <em>within each parallel assembly
thread</em> (see <a href="/implementation/">implementation notes</a> for details).</p>

<h3 id="transducers:94d9a081cd1256334373c8ca6fb6276c">Transducers</h3>

<p>As explained in the <a href="/implementation/">implementation notes</a>, dendrite performs record
assembly in parallel by transforming lists of striped records (by default 256 records per bundle) into a
<a href="https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/IChunk.java
">Chunk</a> of assembled records. This is a classic reduce operation. The
<code>d/eduction</code> function can modify this reduction with a transducer (or a composition of several
transducers). As long as the transducer is stateless, this is completely equivalent to calling
<code>clojure.core/eduction</code> on the sequence returned by <code>d/read</code>. However it is noticeably faster since the
transducer is applied in the parallel record chunk assembly threads.</p>

<p>The example below leverages transducers to compute the frequencies of image sizes in the whole dataset. Since
each record can define several images, we need to concatenate all the image information together before
passing it to <code>frequencies</code>.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">file</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">r</span>
      <span class="p">(</span><span class="nf">d/read</span> <span class="p">{</span><span class="ss">:sub-schema-in</span> <span class="p">[</span><span class="ss">:images</span><span class="p">]</span>
               <span class="ss">:query</span> <span class="p">[{</span><span class="ss">:size</span> <span class="ss">&#39;_</span><span class="p">}]})</span>
      <span class="p">(</span><span class="nf">d/eduction</span> <span class="nv">cat</span> <span class="p">(</span><span class="nb">map </span><span class="ss">:size</span><span class="p">))</span>
      <span class="nv">frequencies</span><span class="p">))</span>
<span class="c1">;= {&quot;SMALL&quot; 150603, &quot;LARGE&quot; 149987}</span>
</pre></div>
</p>

<p>It is of course possible to combine these transducers with a fold operation. In this case, the transducers are
applied to the fold&rsquo;s reduce function (instead of the default chunk assembly reduce function in the example
above). This efficiently produces the expected result.</p>

<p>For example, the somewhat contrived example below quickly computes the sum of all the heights of all images.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">file</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">r</span>
      <span class="p">(</span><span class="nf">d/read</span> <span class="p">{</span><span class="ss">:sub-schema-in</span> <span class="p">[</span><span class="ss">:images</span><span class="p">]</span>
               <span class="ss">:query</span> <span class="p">[{</span><span class="ss">:height</span> <span class="ss">&#39;_</span><span class="p">}]})</span>
      <span class="p">(</span><span class="nf">d/eduction</span> <span class="nv">cat</span> <span class="p">(</span><span class="nb">map </span><span class="ss">:height</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">r/fold</span> <span class="nv">+</span><span class="p">)))</span>
<span class="c1">;= 59661367</span>
</pre></div>
</p>

<h3 id="fast-sampling:94d9a081cd1256334373c8ca6fb6276c">Fast sampling</h3>

<p>Dendrite can quickly skip records based on their position within the file using the <code>d/sample</code> function. This
is useful for sampling records from a file. Note that this only short-circuits record assembly, as the column
values must still be decoded before being skipped.</p>

<p>The example below uses <code>d/sample</code> to read one of ten records.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">file</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">d/read</span> <span class="nv">r</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">d/sample</span> <span class="o">#</span><span class="p">(</span><span class="nb">zero? </span><span class="p">(</span><span class="nf">mod</span> <span class="nv">%</span> <span class="mi">10</span><span class="p">)))</span>
       <span class="nv">count</span><span class="p">))</span>
<span class="c1">;= 10000</span>
</pre></div>
</p>

<h3 id="indexing:94d9a081cd1256334373c8ca6fb6276c">Indexing</h3>

<p>The sampling functionality in the previous may not suffice if, for instance, you need to apply different
sample rates by class of records. For this use-case and others, dendrite has a generic way of inserting
indices into records using the <code>d/index-by</code> function that works like a parallel version of <code>map-indexed</code>. Note
that this indexing only occurs <em>after</em> record assembly so this won&rsquo;t deliver read time improvements as
sampling.</p>

<p>Let&rsquo;s see how this works.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">file</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">d/read</span> <span class="nv">r</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">d/index-by</span> <span class="o">#</span><span class="p">(</span><span class="nb">assoc </span><span class="nv">%2</span> <span class="ss">:index</span> <span class="nv">%1</span><span class="p">))</span>
       <span class="nv">first</span><span class="p">))</span>
<span class="c1">;= {:index 0, :media {..}, :images [..]}</span>
</pre></div>
</p>

<h3 id="reader-tags:94d9a081cd1256334373c8ca6fb6276c">Reader tags</h3>

<p>The previous transformations either modify the <em>sequence</em> of records after assembly (reducers, transducers,
indexing) or short-circuit record assembly altogether (sampling). The reader tags described in this section
are very similar to <a href="https://github.com/edn-format/edn
">EDN tags</a> and enable customizing the record assembly
itself. Furthermore, when used in combination with dictionary-encoded columns they deliver one of dendrite&rsquo;s
key performance optimizations.</p>

<p>This first example uses tags to output clojure records.</p>

<p>Let&rsquo;s begin by defining clojure records for our main types.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="kd">defrecord </span><span class="nv">MediaContent</span> <span class="p">[</span><span class="nv">id</span> <span class="nv">media</span> <span class="nv">images</span><span class="p">])</span>
<span class="p">(</span><span class="kd">defrecord </span><span class="nv">Media</span> <span class="p">[</span><span class="nv">format</span> <span class="nv">height</span> <span class="nv">width</span> <span class="nv">copyright</span> <span class="nv">duration</span> <span class="nv">size</span>
                  <span class="nv">title</span> <span class="nv">persons</span> <span class="nv">bitrate</span> <span class="nv">player</span> <span class="nv">uri</span><span class="p">])</span>
<span class="p">(</span><span class="kd">defrecord </span><span class="nv">Image</span> <span class="p">[</span><span class="nv">title</span> <span class="nv">uri</span> <span class="nv">height</span> <span class="nv">width</span> <span class="nv">size</span><span class="p">])</span>
</pre></div>
</p>

<p>Then, let&rsquo;s add tags to our dendrite query.
<div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">query</span> <span class="p">(</span><span class="nf">d/tag</span> <span class="ss">&#39;media-content</span>
            <span class="p">{</span><span class="ss">:id</span> <span class="ss">&#39;_</span>
             <span class="ss">:media</span> <span class="p">(</span><span class="nf">d/tag</span> <span class="ss">&#39;media</span> <span class="ss">&#39;_</span><span class="p">)</span>
             <span class="ss">:images</span> <span class="p">[(</span><span class="nf">d/tag</span> <span class="ss">&#39;image</span> <span class="ss">&#39;_</span><span class="p">)]}))</span>
</pre></div>
</p>

<p>Note that this query can be serialized to EDN.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">query-str</span> <span class="p">(</span><span class="nb">pr-str </span><span class="nv">query</span><span class="p">))</span>
<span class="c1">;= &quot;#media-content {:id _, :media #media _, :images [#image _]}&quot;</span>

<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.edn</span> <span class="ss">:as</span> <span class="nv">edn</span><span class="p">])</span>
<span class="p">(</span><span class="nb">= </span><span class="nv">query</span> <span class="p">(</span><span class="nf">edn/read-string</span> <span class="p">{</span><span class="ss">:default</span> <span class="nv">d/tag</span><span class="p">}</span> <span class="nv">query-str</span><span class="p">))</span>
<span class="c1">; true</span>
</pre></div>
</p>

<p>Finally, lets use our tagged query to build these nested clojure records.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">file</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">r</span>
      <span class="p">(</span><span class="nf">d/read</span> <span class="p">{</span><span class="ss">:query</span> <span class="nv">query</span>
               <span class="ss">:readers</span> <span class="p">{</span><span class="ss">&#39;media-content</span> <span class="nv">map-&gt;MediaContent</span>
                         <span class="ss">&#39;media</span> <span class="nv">map-&gt;Media</span>
                         <span class="ss">&#39;image</span> <span class="nv">map-&gt;Image</span><span class="p">}})</span>
      <span class="nv">last</span><span class="p">))</span>
<span class="c1">;= #user.MediaContent{</span>
<span class="c1">;    :id 99999,</span>
<span class="c1">;    :media #user.Media{</span>
<span class="c1">;             :format &quot;MOV&quot;,</span>
<span class="c1">;             :height 480,</span>
<span class="c1">;             :width 480,</span>
<span class="c1">;             :copyright &quot;Mybuzz&quot;,</span>
<span class="c1">;             :duration 1747,</span>
<span class="c1">;             :size 31973,</span>
<span class="c1">;             :title &quot;Pellentesque viverra peed ac diam.&quot;,</span>
<span class="c1">;             :persons [&quot;Antonio Harris&quot;</span>
<span class="c1">;                       &quot;Harold Price&quot;</span>
<span class="c1">;                       &quot;Janice Shaw&quot;],</span>
<span class="c1">;             :bitrate 4000,</span>
<span class="c1">;             :player &quot;FLASH&quot;,</span>
<span class="c1">;             :uri &quot;http://merriam-webster.com/.../turpis.js&quot;},</span>
<span class="c1">;             :images [#user.Image{</span>
<span class="c1">;                        :title &quot;Fusce posuere felis sed lacus.&quot;,</span>
<span class="c1">;                        :uri &quot;https://army.mil/.../auctor.html&quot;,</span>
<span class="c1">;                        :height 240,</span>
<span class="c1">;                        :width 160,</span>
<span class="c1">;                        :size &quot;LARGE&quot;}]}</span>
</pre></div>
</p>

<p>Reader tags on leaf values trigger an important optimization when those leaf values are dictionary-encoded. In
that case, the reader function gets applied to the dictionary itself in the column decoding thread, rather
than to each value in the record assembly thread. In effect, this computes the function once for each
<em>distinct</em> value in the column, rather than on each value.</p>

<p>In some situations this can lead to an order of magnitude speedup. A good example is a machine learning
training set for an algorithm that uses the <a href="https://en.wikipedia.org/wiki/Feature_hashing
">hashing trick</a>. Computing tens of
millions of hashes is very expensive, but computing just a few thousand distinct hashes is quite cheap.</p>

<p>Let&rsquo;s see how this plays out on the tutorial dataset. First let&rsquo;s define a generic hash function based on
clojure&rsquo;s built-in implementation of <a href="https://en.wikipedia.org/wiki/MurmurHash
">murmur hash</a>.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="kd">defn </span><span class="nv">murmur-hash</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">clojure.lang.Murmur3/hashUnencodedChars</span> <span class="p">(</span><span class="nb">str </span><span class="nv">x</span><span class="p">)))</span>
</pre></div>
</p>

<p>Then we define two queries for the dictionary columns of the media object, one tagged, the other not.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">dict-ks</span>
  <span class="p">[</span><span class="ss">:format</span>, <span class="ss">:width</span>, <span class="ss">:copyright</span>, <span class="ss">:bitrate</span>, <span class="ss">:player</span>, <span class="ss">:height</span><span class="p">])</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">map-vals</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">m</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">reduce-kv</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">m</span> <span class="nv">k</span> <span class="nv">v</span><span class="p">]</span> <span class="p">(</span><span class="nb">assoc </span><span class="nv">m</span> <span class="nv">k</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">v</span><span class="p">)))</span> <span class="p">{}</span> <span class="nv">m</span><span class="p">))</span>

<span class="c1">; Regular query for the fields in `dict-ks`</span>
<span class="p">(</span><span class="k">def </span><span class="nv">query</span>
  <span class="p">(</span><span class="nb">reduce </span><span class="o">#</span><span class="p">(</span><span class="nb">assoc </span><span class="nv">%1</span> <span class="nv">%2</span> <span class="ss">&#39;_</span><span class="p">)</span> <span class="p">{}</span> <span class="nv">dict-ks</span><span class="p">))</span>

<span class="c1">; Query in with each field in `dict-ks` is tagged with &#39;hash</span>
<span class="p">(</span><span class="k">def </span><span class="nv">tagged-query</span>
  <span class="p">(</span><span class="nf">map-vals</span> <span class="o">#</span><span class="p">(</span><span class="nf">d/tag</span> <span class="ss">&#39;hash</span> <span class="nv">%</span><span class="p">)</span> <span class="nv">query</span><span class="p">))</span>
</pre></div>
</p>

<p>Now let&rsquo;s compare the performance of hashing all the values for the fields in <code>dict-ks</code>, using a transducer on
the one hand, and reader tags on the other.</p>

<p><div class="highlight"><pre><span class="c1">; Hash all values with a transducer</span>
<span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">file</span><span class="p">)]</span>
        <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">r</span>
             <span class="p">(</span><span class="nf">d/read</span> <span class="p">{</span><span class="ss">:sub-schema-in</span> <span class="p">[</span><span class="ss">:media</span><span class="p">]</span>
                      <span class="ss">:query</span> <span class="nv">query</span><span class="p">})</span>
             <span class="p">(</span><span class="nf">d/eduction</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="nb">partial </span><span class="nv">map-vals</span> <span class="nv">murmur-hash</span><span class="p">)))</span>
             <span class="nv">last</span><span class="p">)))</span>
<span class="c1">;= &quot;Elapsed time: 97.027783 msecs&quot;</span>
<span class="c1">;  {:format -992991939, :width 2996761, ... }</span>

<span class="c1">; Hash all distinct values in dictionaries</span>
<span class="p">(</span><span class="nb">time </span><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">file</span><span class="p">)]</span>
        <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">r</span>
             <span class="p">(</span><span class="nf">d/read</span> <span class="p">{</span><span class="ss">:sub-schema-in</span> <span class="p">[</span><span class="ss">:media</span><span class="p">]</span>
                      <span class="ss">:query</span> <span class="nv">tagged-query</span>
                      <span class="ss">:readers</span> <span class="p">{</span><span class="ss">&#39;hash</span> <span class="nv">murmur-hash</span><span class="p">}})</span>
             <span class="nv">last</span><span class="p">)))</span>
<span class="c1">;= &quot;Elapsed time: 34.897017 msecs&quot;</span>
<span class="c1">;  {:format -992991939, :width 2996761, ... }</span>
</pre></div>
</p>

<p>In this example, reader tags on dictionary columns yield a 3x speed improvement.</p>

<h2 id="custom-types:94d9a081cd1256334373c8ca6fb6276c">Custom types</h2>

<p>Dendrite&rsquo;s <a href="#supported-types:94d9a081cd1256334373c8ca6fb6276c">built-in types</a> should cover most use cases, but if not, it is
possible to define new types.</p>

<p>A custom needs to define the following:</p>

<ul>
<li><em>type</em>: the name of the new type</li>
<li><em>base-type</em>: the name of an existing type that the new type can be serialized to</li>
<li><em>to base-type function</em>: a function to serialize to new type to the base type</li>
<li><em>from base-type function</em>: a function to deserialize the base type into the new type</li>
</ul>

<p>Optionally, it is also possible to define a <em>coercion function</em> to ensure that incoming values are indeed in
the <em>base-type</em>.</p>

<p>Let&rsquo;s see how this works on a simple example. We are going to define a new <code>edn</code> type that can contain
arbitrary EDN data. This could be useful if parts of your data must accommodate a completely free-form
datastructure.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.edn</span> <span class="ss">:as</span> <span class="nv">edn</span><span class="p">])</span>

<span class="p">(</span><span class="k">def </span><span class="nv">edn-type</span> <span class="p">{</span><span class="ss">:type</span> <span class="ss">&#39;edn</span>
               <span class="ss">:base-type</span> <span class="ss">&#39;string</span>
               <span class="ss">:to-base-type-fn</span> <span class="nv">pr-str</span>
               <span class="ss">:from-base-type-fn</span> <span class="nv">edn/read-string</span><span class="p">})</span>

<span class="c1">; A trivial schema with the new type</span>
<span class="p">(</span><span class="k">def </span><span class="nv">schema</span> <span class="p">{</span><span class="ss">:blob-id</span> <span class="ss">&#39;int</span> <span class="ss">:blob</span> <span class="ss">&#39;edn</span><span class="p">})</span>

<span class="p">(</span><span class="k">def </span><span class="nv">file</span> <span class="s">&quot;custom-type-example.den&quot;</span><span class="p">)</span>

<span class="c1">; Write two records to a file</span>
<span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">w</span> <span class="p">(</span><span class="nf">d/file-writer</span> <span class="p">{</span><span class="ss">:custom-types</span> <span class="p">[</span><span class="nv">edn-type</span><span class="p">]}</span>
                             <span class="nv">schema</span>
                             <span class="nv">file</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">.write</span> <span class="nv">w</span> <span class="p">{</span><span class="ss">:blob-id</span> <span class="mi">1</span> <span class="ss">:blob</span> <span class="p">{</span><span class="ss">:foo</span> <span class="mi">2</span><span class="p">}})</span>
  <span class="p">(</span><span class="nf">.write</span> <span class="nv">w</span> <span class="p">{</span><span class="ss">:blob-id</span> <span class="mi">2</span> <span class="ss">:blob</span> <span class="p">[</span><span class="o">#</span><span class="p">{</span><span class="ss">:bar</span><span class="p">}]}))</span>

<span class="c1">; Read them</span>
<span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="p">{</span><span class="ss">:custom-types</span> <span class="p">[</span><span class="nv">edn-type</span><span class="p">]}</span> <span class="nv">file</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">doall </span><span class="p">(</span><span class="nf">d/read</span> <span class="nv">r</span><span class="p">)))</span>
<span class="c1">;= ({:blob-id 1, :blob {:foo 2}}</span>
<span class="c1">;   {:blob-id 2, :blob [#{:bar}]})</span>
</pre></div>
</p>

<p>Note that we have to pass the <code>:custom-types</code> option to both the reader and the writer. If the write does not
have that option it will throw an exception. The reader, however, degrades gracefully by reading the <code>edn</code>
values in its base-type (<code>string</code> in this example).</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">file</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">doall </span><span class="p">(</span><span class="nf">d/read</span> <span class="nv">r</span><span class="p">)))</span>
<span class="c1">;= ({:blob-id 1, :blob &quot;{:foo 2}&quot;}</span>
<span class="c1">;   {:blob-id 2, :blob &quot;[#{:bar}]&quot;})</span>
</pre></div>
</p>

<p>Note how the <code>:blob</code> values are read as strings if the <code>:custom-types</code> option is not defined.</p>

<h2 id="encoding-and-compression:94d9a081cd1256334373c8ca6fb6276c">Encoding and compression</h2>

<h3 id="available-encodings:94d9a081cd1256334373c8ca6fb6276c">Available encodings</h3>

<p>Under the hood, dendrite implements, for each primitive value type, several types of encodings that try to
accommodate very different types of data. The precise details of each encoding is explained in the
<a href="/format/">file format</a>. In the clojure API, encoding are denoted by a symbol. The table
below lists the available encodings for each primitive type.</p>

<table>
<thead>
<tr>
<th>Type</th>
<th>Encodings</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>boolean</code></td>
<td><code>plain</code>, <code>dictionary</code></td>
</tr>

<tr>
<td><code>int</code></td>
<td><code>plain</code>, <code>dictionary</code>, <code>frequency</code>, <code>vlq</code>, <code>zigzag</code>, <code>packed-run-length</code>, <code>delta</code></td>
</tr>

<tr>
<td><code>long</code></td>
<td><code>plain</code>, <code>dictionary</code>, <code>frequency</code>, <code>vlq</code>, <code>zigzag</code>, <code>delta</code></td>
</tr>

<tr>
<td><code>float</code></td>
<td><code>plain</code>, <code>dictionary</code>, <code>frequency</code></td>
</tr>

<tr>
<td><code>double</code></td>
<td><code>plain</code>, <code>dictionary</code>, <code>frequency</code></td>
</tr>

<tr>
<td><code>byte-array</code></td>
<td><code>plain</code>, <code>dictionary</code>, <code>frequency</code>, <code>delta-length</code>, <code>incremental</code></td>
</tr>

<tr>
<td><code>fixed-length-byte-array</code></td>
<td><code>plain</code>, <code>dictionary</code>, <code>frequency</code></td>
</tr>
</tbody>
</table>

<h3 id="available-compression:94d9a081cd1256334373c8ca6fb6276c">Available compression</h3>

<p>In many cases the encodings do a very good job of compressing the data. However, particularly for string
columns, is it often worth applying compression on top of the encoded data. At the moment, dendrite only
supports <a href="https://en.wikipedia.org/wiki/DEFLATE
">deflate</a> compression (denoted by the <code>deflate</code> symbol in the clojure
API). Earlier versions also supported <a href="https://en.wikipedia.org/wiki/LZ4_%28compression_algorithm%29
">LZ4</a> but it never seemed to improve much over just
using the encodings without compression so it was dropped. However, it would be easy to re-introduce support
in future versions.</p>

<h3 id="manual-column-settings:94d9a081cd1256334373c8ca6fb6276c">Manual column settings</h3>

<p>By default, dendrite uses a mix of straightforward heuristics (number of distinct values, max, min, etc.) and
greedy optimizations to pick a good <a href="/format/">encoding</a> and <a href="/format/">compression</a> for each column. This was a deliberate design decision to avoid forcing these decisions onto
the end-user. Indeed, manually specifying such settings for each column quickly becomes tedious as the number
of columns grows.</p>

<p>However, in some situations in can be advantageous to specify desired encodings up-front. For example, if
write speed is a concern, you may want to optimize the choice of encodings and compressions just once and
re-use those choices for all subsequent writes. Similarly, should the built-in heuristics produce a
sub-optimal design, you may want to override them for a specific column. As we will see, dendrite supports all
these use-cases.</p>

<p>Dendrite&rsquo;s column encoding &amp; compression optimizer has three modes:</p>

<ul>
<li><strong>default</strong>: all the columns that have <code>plain</code> encoding and <code>none</code> compression are optimized;</li>
<li><strong>all</strong>: all columns are optimized;</li>
<li><strong>none</strong>: no columns are optimized.</li>
</ul>

<p>Furthermore, the <code>d/col</code> function can annotate the write schema to request specific encodings and
compressions. The <code>d/full-schema</code> function can retrieve the <em>fully-annotated</em> schema from an existing
file. Let&rsquo;s see how this works on a simple example.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">tmp-file</span> <span class="s">&quot;/path/to/tmp-file.den&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">get-full-schema</span> <span class="p">[</span><span class="nv">file</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">file</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">d/full-schema</span> <span class="nv">r</span><span class="p">)))</span>

<span class="c1">; Default behavior</span>
<span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">w</span> <span class="p">(</span><span class="nf">d/file-writer</span> <span class="ss">&#39;int</span> <span class="nv">tmp-file</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">.writeAll</span> <span class="nv">w</span> <span class="p">(</span><span class="nb">range </span><span class="mi">100</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">get-full-schema</span> <span class="nv">tmp-file</span><span class="p">)</span>
<span class="c1">;= #col [int delta]</span>
<span class="c1">; Delta encoding with no compression</span>

<span class="c1">; Disable optimization</span>
<span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">w</span> <span class="p">(</span><span class="nf">d/file-writer</span> <span class="p">{</span><span class="ss">:optimize-columns?</span> <span class="ss">:none</span><span class="p">}</span>
                             <span class="ss">&#39;int</span> <span class="nv">tmp-file</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">.writeAll</span> <span class="nv">w</span> <span class="p">(</span><span class="nb">range </span><span class="mi">100</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">get-full-schema</span> <span class="nv">tmp-file</span><span class="p">)</span>
<span class="c1">;= int</span>
<span class="c1">; Plain int encoding with no compression</span>

<span class="c1">; Manually pick VLQ encoding</span>
<span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">w</span> <span class="p">(</span><span class="nf">d/file-writer</span> <span class="p">(</span><span class="nf">d/col</span> <span class="ss">&#39;int</span> <span class="ss">&#39;vlq</span> <span class="ss">&#39;deflate</span><span class="p">)</span> <span class="nv">tmp-file</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">.writeAll</span> <span class="nv">w</span> <span class="p">(</span><span class="nb">range </span><span class="mi">100</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">get-full-schema</span> <span class="nv">tmp-file</span><span class="p">)</span>
<span class="c1">;= #col [int vlq deflate]</span>
<span class="c1">; VLQ encoding with deflate compression</span>

<span class="c1">; Manually pick VLQ encoding, but force optimization of all columns</span>
<span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">w</span> <span class="p">(</span><span class="nf">d/file-writer</span> <span class="p">{</span><span class="ss">:optimize-columns?</span> <span class="ss">:all</span><span class="p">}</span>
                             <span class="p">(</span><span class="nf">d/col</span> <span class="ss">&#39;int</span> <span class="ss">&#39;vlq</span><span class="p">)</span> <span class="nv">tmp-file</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">.writeAll</span> <span class="nv">w</span> <span class="p">(</span><span class="nb">range </span><span class="mi">100</span><span class="p">)))</span>
<span class="c1">;= #col [int delta]</span>
<span class="c1">; Delta encoding with no compression</span>
</pre></div>
</p>

<p>Note that object returned by <code>d/col</code> is printed using an EDN <code>#col</code> tag. Indeed, there is nothing special
about these <em>fully-annotated</em> schemas as they can be manipulated and serialized just like the schemas
described <a href="#schema-serialization:94d9a081cd1256334373c8ca6fb6276c">earlier</a> in this tutorial.</p>

<h3 id="compression-thresholds:94d9a081cd1256334373c8ca6fb6276c">Compression thresholds</h3>

<p>When determining whether or not to use compression for a given column, dendrite estimates a compression ratio
for each of the available compression algorithms (only <a href="https://en.wikipedia.org/wiki/DEFLATE
">deflate</a> at the moment) by
compressing one data page with each. If this compression ratio is greater than a certain threshold that
compression algorithm is kept for further consideration. Finally dendrite selects from all passing algorithms
the one that yielded the smallest page.</p>

<p>These thresholds are configurable through the <code>:compression-thresholds</code> writer option and allow the user finer
control over the file-size vs. read speed trade-off. Let&rsquo;s see how this works on a simple example.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">tmp-file</span> <span class="s">&quot;/path/to/tmp-file.den&quot;</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">first-col-stats</span> <span class="p">[</span><span class="nv">file</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">file</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">select-keys </span><span class="p">(</span><span class="nb">-&gt; </span><span class="nv">r</span> <span class="nv">d/stats</span> <span class="ss">:columns</span> <span class="nv">first</span><span class="p">)</span>
                 <span class="p">[</span><span class="ss">:compression</span> <span class="ss">:data-length</span><span class="p">])))</span>

<span class="c1">; Default: use deflate only if it achieves a 1.5 compression</span>
<span class="c1">; ratio or higher</span>
<span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">w</span> <span class="p">(</span><span class="nf">d/file-writer</span> <span class="ss">&#39;int</span> <span class="nv">tmp-file</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">.writeAll</span> <span class="nv">w</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10000</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">first-col-stats</span> <span class="nv">tmp-file</span><span class="p">)</span>
<span class="c1">;= {:compression deflate, :data-length 283}</span>

<span class="c1">; Only pick deflate compression if it achieves a compression ratio</span>
<span class="c1">; of 3 or higher</span>
<span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">w</span> <span class="p">(</span><span class="nf">d/file-writer</span> <span class="p">{</span><span class="ss">:compression-thresholds</span> <span class="p">{</span><span class="ss">&#39;deflate</span> <span class="mi">3</span><span class="p">}}</span>
                             <span class="ss">&#39;int</span> <span class="nv">tmp-file</span><span class="p">)]</span>
  <span class="p">(</span><span class="nf">.writeAll</span> <span class="nv">w</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10000</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">first-col-stats</span> <span class="nv">tmp-file</span><span class="p">)</span>
<span class="c1">;= {:compression none, :data-length 716}</span>
</pre></div>
</p>

<p>The compressed length (283 bytes) is just 2.5 times smaller than the uncompressed length (716 bytes) so
deflate compression is selected in the former example but not in the latter.</p>

<h2 id="file-layout-customization:94d9a081cd1256334373c8ca6fb6276c">File layout customization</h2>

<p>Dendrite tries to provide sensible defaults for all low-level settings. When defaults don&rsquo;t make sense, it
resorts to write-time heuristics to optimize for a good compactness/read-speed trade-off. In some cases
though, you may want to override the low-level settings. This sections discusses options to customize the
<a href="/format/">file layout</a>.</p>

<h3 id="page-lengths:94d9a081cd1256334373c8ca6fb6276c">Page lengths</h3>

<p>Pages are the basic unit of parallelism and compression. As explained in the <a href="/implementation/">implementation notes</a>, each page is lazily decoded (and possibly decompressed) in a separate thread. The
default page size is 256 KB. Since the first page of each column must be decoded before record assembly can
begin, excessively large pages increase the likelihood that a very large column will become a
bottleneck. However larger pages also allow for more efficient encoding and compression. Page size also
influences the heuristic for the maximum size of dictionary pages.</p>

<p>Let&rsquo;s see how this plays out on an example. We re-use the same tutorial file that was downloaded at the
beginning of the <a href="#file-introspection:94d9a081cd1256334373c8ca6fb6276c">file introspection</a> section.</p>

<p><div class="highlight"><pre><span class="c1">; &#39;file&#39; points to the provided tutorial, &#39;file2&#39; to a tmp file</span>
<span class="p">(</span><span class="k">def </span><span class="nv">file</span> <span class="s">&quot;/path/to/tutorial.den&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">file2</span> <span class="s">&quot;/path/to/tmp-file.den&quot;</span><span class="p">)</span>

<span class="c1">; Fetch the schema from file</span>
<span class="p">(</span><span class="k">def </span><span class="nv">schema</span> <span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">file</span><span class="p">)]</span>
              <span class="p">(</span><span class="nf">d/schema</span> <span class="nv">r</span><span class="p">)))</span>

<span class="c1">; Copy file to file2 using a smaller page size</span>
<span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">file</span><span class="p">)</span>
            <span class="nv">w</span> <span class="p">(</span><span class="nf">d/file-writer</span> <span class="p">{</span><span class="ss">:data-page-length</span> <span class="mi">1024</span><span class="p">}</span> <span class="nv">schema</span> <span class="nv">file2</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">o</span> <span class="p">(</span><span class="nf">d/read</span> <span class="nv">r</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">.write</span> <span class="nv">w</span> <span class="nv">o</span><span class="p">)))</span>
</pre></div>
</p>

<p>Note that <code>file2</code> is considerably larger than <code>file</code>.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.java.io</span> <span class="ss">:as</span> <span class="nv">io</span><span class="p">])</span>

<span class="p">(</span><span class="nf">.length</span> <span class="p">(</span><span class="nf">io/as-file</span> <span class="nv">file</span><span class="p">))</span>
<span class="c1">;= 6421801</span>

<span class="p">(</span><span class="nf">.length</span> <span class="p">(</span><span class="nf">io/as-file</span> <span class="nv">file2</span><span class="p">))</span>
<span class="c1">;= 19775457</span>
</pre></div>
</p>

<p>Let&rsquo;s have a closer look at page lengths and counts in both. We&rsquo;ll first define a <code>print-page-stats</code> function.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.pprint</span> <span class="ss">:as</span> <span class="nv">pp</span><span class="p">])</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">print-page-stats</span> <span class="p">[</span><span class="nv">file</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">file</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">d/stats</span> <span class="nv">r</span><span class="p">)</span>
         <span class="ss">:columns</span>
         <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">select-keys </span><span class="nv">%</span> <span class="p">[</span><span class="ss">:length</span> <span class="ss">:encoding</span> <span class="ss">:compression</span>
                               <span class="ss">:num-pages</span><span class="p">]))</span>
         <span class="p">(</span><span class="nb">sort-by </span><span class="ss">:length</span><span class="p">)</span>
         <span class="nv">pp/print-table</span><span class="p">)))</span>
</pre></div>
</p>

<p>Let&rsquo;s use this function to analyze both files.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nf">print-page-stats</span> <span class="nv">file</span><span class="p">)</span>
<span class="c1">; | :length |         :encoding | :compression | :num-pages |</span>
<span class="c1">; |---------+-------------------+--------------+------------|</span>
<span class="c1">; |    2137 |             delta |      deflate |          1 |</span>
<span class="c1">; |   12537 |        dictionary |         none |          2 |</span>
<span class="c1">; |   25050 |        dictionary |         none |          2 |</span>
<span class="c1">; |   37550 |        dictionary |         none |          2 |</span>
<span class="c1">; |   37551 |        dictionary |         none |          2 |</span>
<span class="c1">; |   37552 |        dictionary |         none |          2 |</span>
<span class="c1">; |   75238 |        dictionary |         none |          3 |</span>
<span class="c1">; |  106425 |        dictionary |         none |          2 |</span>
<span class="c1">; |  116722 |        dictionary |         none |          2 |</span>
<span class="c1">; |  187987 |        dictionary |         none |          3 |</span>
<span class="c1">; |  187988 |        dictionary |         none |          3 |</span>
<span class="c1">; |  209329 |         frequency |         none |          2 |</span>
<span class="c1">; |  212518 | packed-run-length |         none |          1 |</span>
<span class="c1">; |  344648 |        dictionary |         none |          3 |</span>
<span class="c1">; |  753994 |         frequency |      deflate |          3 |</span>
<span class="c1">; | 1009330 |       incremental |      deflate |          5 |</span>
<span class="c1">; | 3064652 |       incremental |      deflate |         13 |</span>

<span class="p">(</span><span class="nf">print-page-stats</span> <span class="nv">file2</span><span class="p">)</span>
<span class="c1">; | :length |         :encoding | :compression | :num-pages |</span>
<span class="c1">; |---------+-------------------+--------------+------------|</span>
<span class="c1">; |    4621 |             delta |      deflate |         79 |</span>
<span class="c1">; |   13790 |        dictionary |         none |         94 |</span>
<span class="c1">; |   26017 |        dictionary |         none |         77 |</span>
<span class="c1">; |   38613 |        dictionary |         none |         80 |</span>
<span class="c1">; |   38618 |        dictionary |         none |         80 |</span>
<span class="c1">; |   38618 |        dictionary |         none |         80 |</span>
<span class="c1">; |   81482 |        dictionary |         none |        259 |</span>
<span class="c1">; |  151937 | packed-run-length |         none |        149 |</span>
<span class="c1">; |  194842 |        dictionary |         none |        276 |</span>
<span class="c1">; |  194847 |        dictionary |         none |        276 |</span>
<span class="c1">; |  215053 | packed-run-length |         none |        212 |</span>
<span class="c1">; |  442669 |      delta-length |      deflate |        415 |</span>
<span class="c1">; | 1636137 |      delta-length |      deflate |       1636 |</span>
<span class="c1">; | 1821422 |       incremental |      deflate |       1713 |</span>
<span class="c1">; | 2309660 |       incremental |      deflate |       2193 |</span>
<span class="c1">; | 5545539 |       incremental |      deflate |       5126 |</span>
<span class="c1">; | 6980630 |       incremental |      deflate |       6467 |</span>
</pre></div>
</p>

<p>Note how the smaller page size increased the number of pages and changed the result of the heuristics for
encoding and compression. In this example, the very small 1KB pages reduced the number of dictionary encodings
and made the compression less efficient.</p>

<h3 id="record-group-length:94d9a081cd1256334373c8ca6fb6276c">Record-group length</h3>

<p>Similarly to the page length, it is possible to tweak the record-group length. The record-group represents the
maximum amount of data that will be held in memory at write-time, and the size of the memory-mapping at
read-time. Due to JVM limitations, the maximum record-group length is 2 GB.</p>

<p>Let&rsquo;s quickly modify the record-group length of the tutorial file (reusing the <code>file</code>, <code>file2</code>, and <code>schema</code>
vars from the previous section.</p>

<p><div class="highlight"><pre><span class="c1">; Copy file to file2 using a smaller record-group-length</span>
<span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">file</span><span class="p">)</span>
            <span class="nv">w</span> <span class="p">(</span><span class="nf">d/file-writer</span> <span class="p">{</span><span class="ss">:record-group-length</span> <span class="p">(</span><span class="nb">* </span><span class="mi">1024</span> <span class="mi">1024</span><span class="p">)}</span>
                             <span class="nv">schema</span> <span class="nv">file2</span><span class="p">)]</span>
  <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">o</span> <span class="p">(</span><span class="nf">d/read</span> <span class="nv">r</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">.write</span> <span class="nv">w</span> <span class="nv">o</span><span class="p">)))</span>
</pre></div>
</p>

<p>Then let&rsquo;s inspect the file stats to see how this changed the file layout.</p>

<p><div class="highlight"><pre><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.pprint</span> <span class="ss">:as</span> <span class="nv">pp</span><span class="p">])</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">print-rg-stats</span> <span class="p">[</span><span class="nv">file</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">r</span> <span class="p">(</span><span class="nf">d/file-reader</span> <span class="nv">file</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">d/stats</span> <span class="nv">r</span><span class="p">)</span>
         <span class="ss">:record-groups</span>
         <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">select-keys </span><span class="nv">%</span> <span class="p">[</span><span class="ss">:num-records</span> <span class="ss">:length</span><span class="p">]))</span>
         <span class="nv">pp/print-table</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">print-rg-stats</span> <span class="nv">file</span><span class="p">)</span>
<span class="c1">; | :num-records | :length |</span>
<span class="c1">; |--------------+---------|</span>
<span class="c1">; |       100000 | 6421208 |</span>

<span class="p">(</span><span class="nf">print-rg-stats</span> <span class="nv">file2</span><span class="p">)</span>
<span class="c1">; | :num-records | :length |</span>
<span class="c1">; |--------------+---------|</span>
<span class="c1">; |        14757 |  994736 |</span>
<span class="c1">; |        15436 | 1029789 |</span>
<span class="c1">; |        15726 | 1048090 |</span>
<span class="c1">; |        15684 | 1050273 |</span>
<span class="c1">; |        15767 | 1049096 |</span>
<span class="c1">; |        15745 | 1049766 |</span>
<span class="c1">; |         6885 |  471042 |</span>
</pre></div>
</p>

<p>In this example, lowering <code>:record-group-length</code> to 1 MB (down from 128 MB by default), created a copy of the
tutorial file with six record-groups instead of just one.</p>

    </div>
  </div>

  
  <div class="toc">
    <nav id="TableOfContents">
<ul>
<li><a href="#tutorial:94d9a081cd1256334373c8ca6fb6276c">Tutorial</a>
<ul>
<li><a href="#read-and-write-files:94d9a081cd1256334373c8ca6fb6276c">Read and write files</a></li>
<li><a href="#supported-types:94d9a081cd1256334373c8ca6fb6276c">Supported types</a></li>
<li><a href="#read-subsets-of-the-data:94d9a081cd1256334373c8ca6fb6276c">Read subsets of the data</a>
<ul>
<li><a href="#sub-schemas:94d9a081cd1256334373c8ca6fb6276c">Sub-schemas</a></li>
<li><a href="#queries:94d9a081cd1256334373c8ca6fb6276c">Queries</a></li>
<li><a href="#sub-schema-queries:94d9a081cd1256334373c8ca6fb6276c">Sub-schema queries</a></li>
</ul></li>
<li><a href="#metadata:94d9a081cd1256334373c8ca6fb6276c">Metadata</a></li>
<li><a href="#opt-into-strictness:94d9a081cd1256334373c8ca6fb6276c">Opt into strictness</a>
<ul>
<li><a href="#tolerant-writes-by-default:94d9a081cd1256334373c8ca6fb6276c">Tolerant writes by default</a></li>
<li><a href="#required-fields:94d9a081cd1256334373c8ca6fb6276c">Required fields</a></li>
<li><a href="#alert-on-extra-fields:94d9a081cd1256334373c8ca6fb6276c">Alert on extra fields</a></li>
<li><a href="#handle-invalid-records:94d9a081cd1256334373c8ca6fb6276c">Handle invalid records</a></li>
<li><a href="#read-missing-columns:94d9a081cd1256334373c8ca6fb6276c">Read missing columns</a></li>
</ul></li>
<li><a href="#schema-manipulation:94d9a081cd1256334373c8ca6fb6276c">Schema manipulation</a>
<ul>
<li><a href="#modify-an-existing-schema:94d9a081cd1256334373c8ca6fb6276c">Modify an existing schema</a></li>
<li><a href="#schema-serialization:94d9a081cd1256334373c8ca6fb6276c">Serialization</a></li>
</ul></li>
<li><a href="#file-introspection:94d9a081cd1256334373c8ca6fb6276c">File introspection</a>
<ul>
<li><a href="#global-stats:94d9a081cd1256334373c8ca6fb6276c">Global stats</a></li>
<li><a href="#column-stats:94d9a081cd1256334373c8ca6fb6276c">Column stats</a></li>
</ul></li>
<li><a href="#read-transformations:94d9a081cd1256334373c8ca6fb6276c">Read transformations</a>
<ul>
<li><a href="#reducers:94d9a081cd1256334373c8ca6fb6276c">Reducers</a></li>
<li><a href="#transducers:94d9a081cd1256334373c8ca6fb6276c">Transducers</a></li>
<li><a href="#fast-sampling:94d9a081cd1256334373c8ca6fb6276c">Fast sampling</a></li>
<li><a href="#indexing:94d9a081cd1256334373c8ca6fb6276c">Indexing</a></li>
<li><a href="#reader-tags:94d9a081cd1256334373c8ca6fb6276c">Reader tags</a></li>
</ul></li>
<li><a href="#custom-types:94d9a081cd1256334373c8ca6fb6276c">Custom types</a></li>
<li><a href="#encoding-and-compression:94d9a081cd1256334373c8ca6fb6276c">Encoding and compression</a>
<ul>
<li><a href="#available-encodings:94d9a081cd1256334373c8ca6fb6276c">Available encodings</a></li>
<li><a href="#available-compression:94d9a081cd1256334373c8ca6fb6276c">Available compression</a></li>
<li><a href="#manual-column-settings:94d9a081cd1256334373c8ca6fb6276c">Manual column settings</a></li>
<li><a href="#compression-thresholds:94d9a081cd1256334373c8ca6fb6276c">Compression thresholds</a></li>
</ul></li>
<li><a href="#file-layout-customization:94d9a081cd1256334373c8ca6fb6276c">File layout customization</a>
<ul>
<li><a href="#page-lengths:94d9a081cd1256334373c8ca6fb6276c">Page lengths</a></li>
<li><a href="#record-group-length:94d9a081cd1256334373c8ca6fb6276c">Record-group length</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
  

</body>
<script src="/js/site.min.js"></script>
</html>

